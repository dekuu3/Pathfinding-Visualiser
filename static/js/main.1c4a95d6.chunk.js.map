{"version":3,"sources":["Algorithms/dijkstra.js","Algorithms/astar.js","Algorithms/depthfirst.js","Algorithms/breadthfirst.js","Algorithms/greedybestfirst.js","PathfindingVisualiser/Node/Node.jsx","PathfindingVisualiser/PathfindingVisualiser.jsx","App.js","index.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighours","sort","nodeA","nodeB","unvisitedNeighbours","neighbours","col","filter","neighbour","getUnvisitedNeighbours","previousNode","popFromArray","arr","element","i","splice","calculateHValue","Math","abs","Node","this","props","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","tableData","PathfindingVisualiser","setAlgorithmStats","traversedNodes","pathLength","document","getElementById","innerHTML","calculateExecutionTime","startTime","elapsedTime","toFixed","setTableData","algorithmName","executionTime","tempPathLength","toString","algorithm","totalNodes","setState","state","renderTableData","index","mouseIsPressed","getInitialGrid","componentDidMount","newGrid","getNewGridWithWallsOn","resetGridExceptWalls","performance","now","nodesInShortestPathOrder","currentNode","unshift","getDijkstraNodesInShortestPathOrder","console","log","animateAlgorithm","openSet","closedSet","gValue","lowestIndex","fValue","includes","tempGValue","hValue","astar","getAstarNodesInShortestPathOrder","stack","pop","depthfirst","getDepthFirstNodesInShortestPathOrder","queue","breadthfirst","getBreadthFirstNodesInShortestPathOrder","pQueue","greedybestfirst","getGreedyBestFirstNodesInShortestPathOrder","setTimeout","animateShortestPath","resetGrid","floor","random","text","class","onClick","visualiseDijkstra","visualiseAstar","visualiseDepthFirst","visualiseBreadthFirst","visualiseGreedyBestFirst","randomizeWalls","href","target","rel","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","Table","setGridIDTextArea","type","placeholder","readOnly","cols","currentRow","createNode","slice","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.1c4a95d6.chunk.js","sourcesContent":["/*\r\nDIJKSTRA Description\r\nYou start at your start node (distance = 0) and assume every other node in the grid has a distance of Infinity.\r\nFrom the starting node, grab all adjacent nodes and update their distance to \"d istance + 1\"\r\n\r\nThis returns all nodes in the order in which they were visited. Also has the nodes point back to their previous nodes to allow us to find the shortest path.\r\n*/\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    let closestNode = unvisitedNodes.shift();\r\n    //console.log(closestNode);\r\n    //if it finds a wall, continue\r\n    if (closestNode.isWall) continue;\r\n    //if the closest node is at a distance of infinity, we stop\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighours(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighours(node, grid) {\r\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n  for (let neighbour of unvisitedNeighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n//Reverses from the finish node to find the shortest path\r\n//Must be called after the dijkstras algorithm\r\nexport function getDijkstraNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/*\r\nA* Description\r\nA* uses a best-first search approach to find the lowest cost way between start and end nodes. It does this via a heuristic function, to determine the order in which to navigate nodes. This heuristic is the sum of two functions (Zarembo & Kodors, 2013):\r\nG — exact cost of the path from initial node to the current node;\r\nH — admissible (not overestimated) cost of reaching the goal from current node;\r\nF = G + H— cost to reach goal, if the current node is chosen as next node in the path. \r\n*/\r\n\r\nexport function astar(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  startNode.gValue = 0;\r\n  openSet.push(startNode);\r\n\r\n  while (openSet.length > 0) {\r\n    let lowestIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++){\r\n      if (openSet[i].fValue < openSet[lowestIndex].fValue) {\r\n        lowestIndex = i;\r\n      }\r\n    }\r\n    let currentNode = openSet[lowestIndex];\r\n    currentNode.isVisited = true;\r\n\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    popFromArray(openSet, currentNode);\r\n    visitedNodesInOrder.push(currentNode);\r\n    closedSet.push(currentNode);\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n\r\n    for (const neighbour of unvisitedNeighbours) {\r\n      if (neighbour.isWall) continue;\r\n\r\n      if (!closedSet.includes(neighbour)) {\r\n        let tempGValue = currentNode.gValue + 1;\r\n        \r\n        if (openSet.includes(neighbour)){\r\n          if (tempGValue < neighbour.gValue) {\r\n            neighbour.gValue = tempGValue;\r\n          }\r\n        } else {\r\n          neighbour.gValue = tempGValue;\r\n          neighbour.hValue = calculateHValue(neighbour, finishNode);\r\n          neighbour.fValue = neighbour.gValue + neighbour.hValue\r\n          neighbour.previousNode = currentNode;\r\n          openSet.push(neighbour)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //no solution found\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction popFromArray(arr, element) {\r\n  for (let i = arr.length-1; i>=0; i--){\r\n    if (arr[i] === element) {\r\n      arr.splice(i,1); \r\n    }\r\n  }\r\n}\r\n\r\n//Gets neighbours on each side of a node\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\n//Calculates Manhattan Distance between 2 coordinates\r\nfunction calculateHValue(node, finishNode) {\r\n  return Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col)};\r\n  \r\n//Reverses from the finish node to find the shortest path\r\n//Must be called after the A* algorithm\r\nexport function getAstarNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/*\r\nDepth-First search is a popular graph or tree traversal algorithm.\r\nIt works by fully exploring the depth of a particular path before exploring its breadth.\r\n*/\r\n\r\nexport function depthfirst(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n\r\n  let stack = [];\r\n  stack.push(startNode);\r\n  \r\n  while (stack.length > 0){\r\n    let currentNode = stack.pop();\r\n\r\n    currentNode.isVisited = true;\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n    \r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n\r\n    for (let neighbour of unvisitedNeighbours) {\r\n      if (neighbour.isWall) continue;\r\n\r\n      neighbour.previousNode = currentNode;\r\n      stack.push(neighbour);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n//Gets neighbours on each side of a node\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  \r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nexport function getDepthFirstNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}","/*\r\nBreadth-first search is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root and explores all of the neighbour nodes at the present depth prior to moving on to the nodes at the next depth level.\r\n*/\r\n\r\nexport function breadthfirst(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n\r\n  let queue = [];\r\n  queue.push(startNode);\r\n\r\n  while (queue.length > 0) {\r\n    let currentNode = queue.shift();\r\n\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n    \r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n\r\n    for (let neighbour of unvisitedNeighbours) {\r\n      if (neighbour.isWall) continue;\r\n      if (queue.includes(neighbour)) continue;\r\n      neighbour.previousNode = currentNode;\r\n      queue.push(neighbour);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n//Gets neighbours on each side of a node\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);  \r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  \r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nexport function getBreadthFirstNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}","/*\r\nGreedy best first search algorithm\r\nObjective is to minimize heuristic function h(n) = g, this is the cost to the current node from the start node\r\n*/\r\n\r\nexport function greedybestfirst(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n\r\n  let pQueue = [];\r\n  startNode.hValue = calculateHValue(startNode, finishNode)\r\n  pQueue.push(startNode);\r\n\r\n  while (pQueue.length > 0) {\r\n    let lowestIndex = 0;\r\n    for (let i = 0; i < pQueue.length; i++){\r\n      if (pQueue[i].hValue < pQueue[lowestIndex].hValue) {\r\n        lowestIndex = i;\r\n      }\r\n    }\r\n    let currentNode = pQueue[lowestIndex];\r\n\r\n    popFromArray(pQueue, currentNode)\r\n\r\n    currentNode.isVisited = true;\r\n\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n\r\n    for (let neighbour of unvisitedNeighbours) {\r\n      if (neighbour.isWall) continue;\r\n      if (pQueue.includes(neighbour)) continue;\r\n      neighbour.previousNode = currentNode;\r\n      neighbour.hValue = calculateHValue(neighbour, finishNode)\r\n      pQueue.push(neighbour);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n//Gets neighbours on each side of a node\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  \r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\n//Calculates Manhattan Distance between 2 coordinates\r\nfunction calculateHValue(node, finishNode) {\r\n  return Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col)};\r\n\r\nfunction popFromArray(arr, element) {\r\n  for (let i = arr.length-1; i>=0; i--){\r\n    if (arr[i] === element) {\r\n      arr.splice(i,1); \r\n    }\r\n  }\r\n}\r\n\r\nexport function getGreedyBestFirstNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}","import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  //Terniary operator correctly displays finish and start nodes\r\n  //render function displays the nodes\r\n  render() {\r\n    let {\r\n      row,\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport {\r\n  dijkstra,\r\n  getDijkstraNodesInShortestPathOrder,\r\n} from \"../Algorithms/dijkstra\";\r\nimport { astar, getAstarNodesInShortestPathOrder } from \"../Algorithms/astar\";\r\nimport { depthfirst, getDepthFirstNodesInShortestPathOrder } from \"../Algorithms/depthfirst\";\r\nimport { breadthfirst, getBreadthFirstNodesInShortestPathOrder } from \"../Algorithms/breadthfirst\";\r\nimport { greedybestfirst, getGreedyBestFirstNodesInShortestPathOrder } from \"../Algorithms/greedybestfirst\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualiser.css\";\r\nimport Table from \"react-bootstrap/Table\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 10;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 40;\r\nlet tableData = [];\r\n\r\nexport default class PathfindingVisualiser extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n    };\r\n  }\r\n\r\n  //Grid setup using nodes\r\n  componentDidMount() {\r\n    let grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  //Event handler for the resetGrid button - it clears all nodes and walls\r\n  resetGrid() {\r\n    let { grid } = this.state;\r\n\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-start\" ||\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n    document.getElementById(\"gridIDTextArea\").innerHTML = null;\r\n    this.componentDidMount();\r\n  }\r\n\r\n  //similar to resetGrid() but this one leaves walls up - preferably to be called before an algorithm runs\r\n  resetGridExceptWalls() {\r\n    let { grid } = this.state;\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-wall\" ||\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-start\" ||\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  //Mouse event handler for mousedown\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallsOn(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  //Mouse event handler for when mouse pointer enters a new node whilst being pressed\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallsOn(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  //Mouse event handler for when mouse button isnt pressed\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  //Fills in the h3 labels with the correct stats\r\n  setAlgorithmStats = (traversedNodes, pathLength) => {\r\n    document.getElementById(\r\n      \"traversedNodes\"\r\n    ).innerHTML = `${traversedNodes.length} nodes`;\r\n\r\n    if (pathLength.length === 1) {\r\n      document.getElementById(\"pathLength\").innerHTML = `No path found`;\r\n    } else {\r\n      document.getElementById(\r\n        \"pathLength\"\r\n      ).innerHTML = `${pathLength.length} nodes`;\r\n    }\r\n  };\r\n\r\n  calculateExecutionTime = (startTime, elapsedTime) => {\r\n    return (elapsedTime - startTime).toFixed(3);\r\n  };\r\n\r\n  //Event handler for the \"visualiseDijkstra\" button which runs the Dijkstra algo\r\n  visualiseDijkstra() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getDijkstraNodesInShortestPathOrder(\r\n      finishNode\r\n    );\r\n    console.log(visitedNodesInOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"Dijkstra\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n  //Event handler for the \"visualiseAstar\" button which runs the A* algo\r\n  visualiseAstar() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    let startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    let finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getAstarNodesInShortestPathOrder(finishNode);\r\n    console.log(nodesInShortestPathOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"A*\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n  //Event handler for the \"visualiseDepthFirst\" button which runs the depth-first search algorithm \r\n  visualiseDepthFirst() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    let startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    let finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = depthfirst(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getDepthFirstNodesInShortestPathOrder(finishNode);\r\n    console.log(nodesInShortestPathOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"Depth-First\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n   //Event handler for the \"visualiseBreadthFirst\" button which runs the breadth-first search algorithm\r\n   visualiseBreadthFirst() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    let startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    let finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = breadthfirst(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getBreadthFirstNodesInShortestPathOrder(finishNode);\r\n    console.log(nodesInShortestPathOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"Breadth-First\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n   //Event handler for the \"visualiseGreedyBestFirst\" button which runs the breadth-first search algorithm\r\n   visualiseGreedyBestFirst() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    let startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    let finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = greedybestfirst(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getGreedyBestFirstNodesInShortestPathOrder(finishNode);\r\n    console.log(nodesInShortestPathOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"Greedy Best-First\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        let node = visitedNodesInOrder[i];\r\n\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-start\" ||\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n        //this was causing this entire react component to re-render every x milliseconds, which was lagging out our pc/animation\r\n        //instead we now update the class of the element to \"visited\"\r\n        //this.setState({ grid: newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //Animates the shortest path\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-start\" ||\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }\r\n      }, 20 * i);\r\n    }\r\n  }\r\n\r\n  randomizeWalls() {\r\n    this.resetGrid();\r\n    \r\n    let { grid } = this.state;\r\n    \r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n            \"node node-start\" ||\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n            \"node node-finish\"\r\n        ) continue;\r\n\r\n        if (Math.floor(Math.random() * 3) === 1) {\r\n          let newGrid = getNewGridWithWallsOn(this.state.grid, row, col);\r\n          this.setState({ grid: newGrid });\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  setGridIDTextArea() {\r\n    let { grid } = this.state;\r\n    let text = \"\";\r\n\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if(document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-start\"){\r\n          text += \"2\";\r\n        }\r\n        if(document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-finish\"){\r\n          text += \"3\"; \r\n        }\r\n        if(document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-wall\"){\r\n          text += \"1\"\r\n        }\r\n        else {\r\n          text += \"0\";\r\n        }\r\n      }\r\n    } \r\n    document.getElementById(\"gridIDTextArea\").innerHTML = text;\r\n    this.setState({state: this.state});\r\n  }\r\n\r\n  setTableData = (algorithmName, executionTime, traversedNodes, pathLength) => {\r\n    let tempPathLength;\r\n    if (pathLength.length === 1) {\r\n      tempPathLength = \"No Path Found\";\r\n    } else {\r\n      tempPathLength = pathLength.length.toString();\r\n    }\r\n\r\n    tableData.push({\r\n      algorithm: algorithmName,\r\n      executionTime: `${executionTime} ms`,\r\n      totalNodes: traversedNodes.length.toString(),\r\n      pathLength: tempPathLength,\r\n    });\r\n\r\n    this.setState({ state: this.state });\r\n  };\r\n\r\n  renderTableData = (tableData, index) => {\r\n    return (\r\n      <tr key={index}>\r\n        <td>{tableData.algorithm}</td>\r\n        <td>{tableData.executionTime}</td>\r\n        <td>{tableData.totalNodes}</td>\r\n        <td>{tableData.pathLength}</td>\r\n      </tr>\r\n    );\r\n  };\r\n\r\n  render() {\r\n    let { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <div class=\"dropdown\">\r\n          <button class=\"dropbtn\">Select Your Algorithm ▼</button>\r\n          <div id=\"myDropdown\" class=\"dropdown-content\">\r\n            <button onClick={() => this.visualiseDijkstra()}>Dijkstra Algorithm</button>\r\n            <button onClick={() => this.visualiseAstar()}>A* Algorithm</button>\r\n            <button onClick={() => this.visualiseDepthFirst()}>Depth-First Search</button>\r\n            <button onClick={() => this.visualiseBreadthFirst()}>Breadth-First Search</button>\r\n            <button onClick={() => this.visualiseGreedyBestFirst()}>Greedy Best First Search</button>\r\n          </div>\r\n        </div>\r\n\r\n        <button class=\"btn\" onClick={() => this.resetGrid()}>Clear Grid</button>\r\n\r\n        <button class=\"btn\" onClick={() => this.randomizeWalls()}>Randomize Walls</button>\r\n\r\n        <a href=\"https://github.com/dekuu3/Pathfinding-Visualiser\" target=\"_blank\" rel=\"noopener noreferrer\">Source Code <code>&lt;/&gt;</code></a>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      row={row}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <h4>\r\n          Execution time: <span id=\"timer\">- -</span>\r\n        </h4>\r\n        <h4>\r\n          Total traversed nodes: <span id=\"traversedNodes\">- -</span>\r\n        </h4>\r\n        <h4>\r\n          Path Length: <span id=\"pathLength\">- -</span>\r\n        </h4>\r\n        <div className=\"algorithmDataTable\">\r\n          <Table>\r\n            <thead>\r\n              <tr>\r\n                <th> Algorithm </th>\r\n                <th> Execution Time </th>\r\n                <th> Nodes Traversed </th>\r\n                <th> Path Length </th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>{tableData.map(this.renderTableData)}</tbody>\r\n          </Table>\r\n        </div>\r\n        <div class=\"gridIDTextArea\">\r\n        <button onClick={() => this.setGridIDTextArea()} class=\"btn\">Update Grid ID</button><br></br>\r\n        <p>This area allows you to see the current grid state above. Keep in mind this is a 50x20 grid.</p>\r\n        <p>This is useful for those who wish to reproduce these results for themselves.</p>\r\n        <p>0 = traversable node | 1 = wall | 2 = start node | 3 = finish node</p>\r\n        <textarea id=\"gridIDTextArea\" type=\"text\" placeholder=\"Grid ID\"  readOnly={true} cols=\"100\"></textarea>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nlet getInitialGrid = () => {\r\n  let grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nlet createNode = (col, row) => {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    gValue: Infinity,\r\n    hValue: Infinity,\r\n    fValue: Infinity,\r\n  };\r\n};\r\n\r\nlet getNewGridWithWallsOn = (grid, row, col) => {\r\n  let newGrid = grid.slice();\r\n  let node = newGrid[row][col];\r\n  let newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualiser from './PathfindingVisualiser/PathfindingVisualiser';       \n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualiser />\n    </div>\n  );\n}\n\nexport default App; ","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}