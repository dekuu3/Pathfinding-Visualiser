{"version":3,"sources":["Algorithms/dijkstra.js","Algorithms/astar.js","Algorithms/depthfirst.js","PathfindingVisualiser/Node/Node.jsx","PathfindingVisualiser/PathfindingVisualiser.jsx","App.js","index.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighours","sort","nodeA","nodeB","unvisitedNeighbours","neighbours","col","filter","neighbour","getUnvisitedNeighbours","previousNode","popFromArray","arr","element","i","splice","calculateHValue","Math","abs","Node","this","props","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","tableData","PathfindingVisualiser","setAlgorithmStats","traversedNodes","pathLength","document","getElementById","innerHTML","calculateExecutionTime","startTime","elapsedTime","toFixed","setTableData","algorithmName","executionTime","tempPathLength","toString","algorithm","totalNodes","setState","state","console","log","renderTableData","index","key","mouseIsPressed","getInitialGrid","componentDidMount","newGrid","getNewGridWithWallsOn","resetGridExceptWalls","performance","now","nodesInShortestPathOrder","currentNode","unshift","getDijkstraNodesInShortestPathOrder","animateAlgorithm","openSet","closedSet","gValue","lowestIndex","fValue","includes","tempGValue","hValue","astar","getAstarNodesInShortestPathOrder","stack","pop","depthfirst","getDepthFirstNodesInShortestPathOrder","setTimeout","animateShortestPath","resetGrid","floor","random","text","class","onClick","visualiseDijkstra","visualiseAstar","visualiseDepthFirst","randomizeWalls","href","target","rel","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","Table","setGridIDTextArea","type","placeholder","readonly","cols","currentRow","createNode","slice","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.cf71c2e9.chunk.js","sourcesContent":["/*\r\nDIJKSTRA Description\r\nYou start at your start node (distance = 0) and assume every other node in the grid has a distance of Infinity.\r\nFrom the starting node, grab all adjacent nodes and update their distance to \"d istance + 1\"\r\n\r\nThis returns all nodes in the order in which they were visited. Also has the nodes point back to their previous nodes to allow us to find the shortest path.\r\n*/\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    let closestNode = unvisitedNodes.shift();\r\n    //console.log(closestNode);\r\n    //if it finds a wall, continue\r\n    if (closestNode.isWall) continue;\r\n    //if the closest node is at a distance of infinity, we stop\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighours(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighours(node, grid) {\r\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n  for (let neighbour of unvisitedNeighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n//Reverses from the finish node to find the shortest path\r\n//Must be called after the dijkstras algorithm\r\nexport function getDijkstraNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/*\r\nA* Description\r\nA* uses a best-first search approach to find the lowest cost way between start and end nodes. It does this via a heuristic function, to determine the order in which to navigate nodes. This heuristic is the sum of two functions (Zarembo & Kodors, 2013):\r\nG — exact cost of the path from initial node to the current node;\r\nH — admissible (not overestimated) cost of reaching the goal from current node;\r\nF = G + H— cost to reach goal, if the current node is chosen as next node in the path. \r\n*/\r\n\r\nexport function astar(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  startNode.gValue = 0;\r\n  openSet.push(startNode);\r\n\r\n  while (openSet.length > 0) {\r\n    let lowestIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++){\r\n      if (openSet[i].fValue < openSet[lowestIndex].fValue) {\r\n        lowestIndex = i;\r\n      }\r\n    }\r\n    let currentNode = openSet[lowestIndex];\r\n    currentNode.isVisited = true;\r\n\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    popFromArray(openSet, currentNode);\r\n    visitedNodesInOrder.push(currentNode);\r\n    closedSet.push(currentNode);\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n\r\n    for (const neighbour of unvisitedNeighbours) {\r\n      if (neighbour.isWall) continue;\r\n\r\n      if (!closedSet.includes(neighbour)) {\r\n        let tempGValue = currentNode.gValue + 1;\r\n        \r\n        if (openSet.includes(neighbour)){\r\n          if (tempGValue < neighbour.gValue) {\r\n            neighbour.gValue = tempGValue;\r\n          }\r\n        } else {\r\n          neighbour.gValue = tempGValue;\r\n          neighbour.hValue = calculateHValue(neighbour, finishNode);\r\n          neighbour.fValue = neighbour.gValue + neighbour.hValue\r\n          neighbour.previousNode = currentNode;\r\n          openSet.push(neighbour)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //no solution found\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction popFromArray(arr, element) {\r\n  for (let i = arr.length-1; i>=0; i--){\r\n    if (arr[i] === element) {\r\n      arr.splice(i,1); \r\n    }\r\n  }\r\n}\r\n\r\n//Gets neighbours on each side of a node\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\n//Calculates Manhattan Distance between 2 coordinates\r\nfunction calculateHValue(node, finishNode) {\r\n  return Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col)};\r\n  \r\n//Reverses from the finish node to find the shortest path\r\n//Must be called after the A* algorithm\r\nexport function getAstarNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/*\r\nDepth-First search is a popular graph or tree traversal algorithm.\r\nIt works by fully exploring the depth of a particular path before exploring its breadth.\r\n*/\r\n\r\nexport function depthfirst(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n\r\n  let stack = [];\r\n  stack.push(startNode);\r\n  \r\n  while (stack.length > 0){\r\n    let currentNode = stack.pop();\r\n    console.log(`${currentNode} just came out of the stack`);\r\n\r\n    currentNode.isVisited = true;\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n    \r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n\r\n    for (let neighbour of unvisitedNeighbours) {\r\n      if (neighbour.isWall) continue;\r\n\r\n      neighbour.previousNode = currentNode;\r\n      stack.push(neighbour);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n//Gets neighbours on each side of a node\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let {col, row} = node;\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  \r\n  return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nexport function getDepthFirstNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}","import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  //Terniary operator correctly displays finish and start nodes\r\n  //render function displays the nodes\r\n  render() {\r\n    let {\r\n      col,\r\n      row,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport {\r\n  dijkstra,\r\n  getDijkstraNodesInShortestPathOrder,\r\n} from \"../Algorithms/dijkstra\";\r\nimport { astar, getAstarNodesInShortestPathOrder } from \"../Algorithms/astar\";\r\nimport { depthfirst, getDepthFirstNodesInShortestPathOrder } from \"../Algorithms/depthfirst\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualiser.css\";\r\nimport Table from \"react-bootstrap/Table\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\nlet tableData = [];\r\n\r\nexport default class PathfindingVisualiser extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n    };\r\n  }\r\n\r\n  //Grid setup using nodes\r\n  componentDidMount() {\r\n    let grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  //Event handler for the resetGrid button - it clears all nodes and walls\r\n  resetGrid() {\r\n    let { grid } = this.state;\r\n\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-start\" ||\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n    document.getElementById(\"gridIDTextArea\").innerHTML = null;\r\n    this.componentDidMount();\r\n  }\r\n\r\n  //similar to resetGrid() but this one leaves walls up - preferably to be called before an algorithm runs\r\n  resetGridExceptWalls() {\r\n    let { grid } = this.state;\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-wall\" ||\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-start\" ||\r\n            document.getElementById(`node-${row}-${col}`).className ===\r\n              \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  //Mouse event handler for mousedown\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallsOn(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  //Mouse event handler for when mouse pointer enters a new node whilst being pressed\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallsOn(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  //Mouse event handler for when mouse button isnt pressed\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  //Fills in the h3 labels with the correct stats\r\n  setAlgorithmStats = (traversedNodes, pathLength) => {\r\n    document.getElementById(\r\n      \"traversedNodes\"\r\n    ).innerHTML = `${traversedNodes.length} nodes`;\r\n\r\n    if (pathLength.length === 1) {\r\n      document.getElementById(\"pathLength\").innerHTML = `No path found`;\r\n    } else {\r\n      document.getElementById(\r\n        \"pathLength\"\r\n      ).innerHTML = `${pathLength.length} nodes`;\r\n    }\r\n  };\r\n\r\n  calculateExecutionTime = (startTime, elapsedTime) => {\r\n    return (elapsedTime - startTime).toFixed(3);\r\n  };\r\n\r\n  //Event handler for the \"visualiseDijkstra\" button which runs the Dijkstra algo\r\n  visualiseDijkstra() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getDijkstraNodesInShortestPathOrder(\r\n      finishNode\r\n    );\r\n    console.log(visitedNodesInOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"Dijkstra\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n  //Event handler for the visualiseAstar\" button which runs the A* algo\r\n  visualiseAstar() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    let startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    let finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getAstarNodesInShortestPathOrder(finishNode);\r\n    console.log(nodesInShortestPathOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"A*\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n  //Event handler for the visualiseAstar\" button which runs the A* algo\r\n  visualiseDepthFirst() {\r\n    this.resetGridExceptWalls();\r\n    let { grid } = this.state;\r\n    let startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    let finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let startTime = performance.now();\r\n    let visitedNodesInOrder = depthfirst(grid, startNode, finishNode);\r\n    let elapsedTime = performance.now();\r\n    let executionTime = this.calculateExecutionTime(startTime, elapsedTime);\r\n    document.getElementById(\"timer\").innerHTML = `${executionTime} ms`;\r\n    let nodesInShortestPathOrder = getDepthFirstNodesInShortestPathOrder(finishNode);\r\n    console.log(nodesInShortestPathOrder);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setAlgorithmStats(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    this.setTableData(\r\n      \"Depth-First\",\r\n      executionTime,\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder\r\n    );\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        let node = visitedNodesInOrder[i];\r\n\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-start\" ||\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n        //this was causing this entire react component to re-render every x milliseconds, which was lagging out our pc/animation\r\n        //instead we now update the class of the element to \"visited\"\r\n        //this.setState({ grid: newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //Animates the shortest path\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n\r\n        if (\r\n          !(\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-start\" ||\r\n            document.getElementById(`node-${node.row}-${node.col}`)\r\n              .className === \"node node-finish\"\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }\r\n      }, 20 * i);\r\n    }\r\n  }\r\n\r\n  randomizeWalls() {\r\n    this.resetGrid();\r\n    \r\n    let { grid } = this.state;\r\n    \r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n            \"node node-start\" ||\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n            \"node node-finish\"\r\n        ) continue;\r\n\r\n        if (Math.floor(Math.random() * 3) === 1) {\r\n          let newGrid = getNewGridWithWallsOn(this.state.grid, row, col);\r\n          this.setState({ grid: newGrid });\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  setGridIDTextArea() {\r\n    let { grid } = this.state;\r\n    let text = \"\";\r\n\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        let { col, row } = node;\r\n        if(document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-start\"){\r\n          text += \"2\";\r\n        }\r\n        if(document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-finish\"){\r\n          text += \"3\"; \r\n        }\r\n        if(document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-wall\"){\r\n          text += \"1\"\r\n        }\r\n        else {\r\n          text += \"0\";\r\n        }\r\n      }\r\n    } \r\n    document.getElementById(\"gridIDTextArea\").innerHTML = text;\r\n    this.setState({state: this.state});\r\n  }\r\n\r\n  setTableData = (algorithmName, executionTime, traversedNodes, pathLength) => {\r\n    let tempPathLength;\r\n    if (pathLength.length === 1) {\r\n      tempPathLength = \"No Path Found\";\r\n    } else {\r\n      tempPathLength = pathLength.length.toString();\r\n    }\r\n\r\n    tableData.push({\r\n      algorithm: algorithmName,\r\n      executionTime: `${executionTime} ms`,\r\n      totalNodes: traversedNodes.length.toString(),\r\n      pathLength: tempPathLength,\r\n    });\r\n\r\n    this.setState({ state: this.state });\r\n    console.log(tableData);\r\n  };\r\n\r\n  renderTableData = (tableData, index) => {\r\n    return (\r\n      <tr key={index}>\r\n        <td>{tableData.algorithm}</td>\r\n        <td>{tableData.executionTime}</td>\r\n        <td>{tableData.totalNodes}</td>\r\n        <td>{tableData.pathLength}</td>\r\n      </tr>\r\n    );\r\n  };\r\n\r\n  render() {\r\n    let { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <div class=\"dropdown\">\r\n          <button class=\"dropbtn\">Select Your Algorithm ▼</button>\r\n          <div id=\"myDropdown\" class=\"dropdown-content\">\r\n            <button onClick={() => this.visualiseDijkstra()}>Dijkstra Algorithm</button>\r\n            <button onClick={() => this.visualiseAstar()}>A* Algorithm</button>\r\n            <button onClick={() => this.visualiseDepthFirst()}>Depth-First Search</button>\r\n          </div>\r\n        </div>\r\n\r\n        <button class=\"btn\" onClick={() => this.resetGrid()}>Clear Grid</button>\r\n\r\n        <button class=\"btn\" onClick={() => this.randomizeWalls()}>Randomize Walls</button>\r\n\r\n        <a href=\"https://github.com/dekuu3/Pathfinding-Visualiser\" target=\"_blank\" rel=\"noopener noreferrer\">Source Code <code>&lt;/&gt;</code></a>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      row={row}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <h4>\r\n          Execution time: <span id=\"timer\">- -</span>\r\n        </h4>\r\n        <h4>\r\n          Total traversed nodes: <span id=\"traversedNodes\">- -</span>\r\n        </h4>\r\n        <h4>\r\n          Path Length: <span id=\"pathLength\">- -</span>\r\n        </h4>\r\n        <div className=\"algorithmDataTable\">\r\n          <Table>\r\n            <thead>\r\n              <tr>\r\n                <th> Algorithm </th>\r\n                <th> Execution Time </th>\r\n                <th> Nodes Traversed </th>\r\n                <th> Path Length </th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>{tableData.map(this.renderTableData)}</tbody>\r\n          </Table>\r\n        </div>\r\n        <div class=\"gridIDTextArea\">\r\n        <button onClick={() => this.setGridIDTextArea()} class=\"btn\">Update Grid ID</button><br></br>\r\n        <p>This area allows you to see the current grid state above. Keep in mind this is a 50x20 grid.</p>\r\n        <p>This is useful for those who wish to reproduce these results for themselves.</p>\r\n        <p>0 = traversable node | 1 = wall | 2 = start node | 3 = finish node</p>\r\n        <textarea id=\"gridIDTextArea\" type=\"text\" placeholder=\"Grid ID\"  readonly=\"true\" cols=\"100\"></textarea>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nlet getInitialGrid = () => {\r\n  let grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nlet createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    gValue: Infinity,\r\n    hValue: Infinity,\r\n    fValue: Infinity,\r\n  };\r\n};\r\n\r\nlet getNewGridWithWallsOn = (grid, row, col) => {\r\n  let newGrid = grid.slice();\r\n  let node = newGrid[row][col];\r\n  let newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualiser from './PathfindingVisualiser/PathfindingVisualiser';       \n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualiser />\n    </div>\n  );\n}\n\nexport default App; ","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}